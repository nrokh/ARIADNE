/*#
The defines and lists have been mostly generated using ChatGPT
*/

#ifndef DRV2605_UTIL_H
#define DRV2605_UTIL_H
#include <Adafruit_DRV2605.h>
#include <Ariadne.h>
#include <DRV2605_EFFECTS.h>

#include "esp_timer.h"
/*
        "#1: Strong Click - 100%",
        "#2: Strong Click - 60%",
        "#3: Strong Click - 30%",
        "#4: Sharp Click - 100%",
        "#5: Sharp Click - 60%",
        "#6: Sharp Click - 30%",
        "#7: Soft Bump - 100%",
        "#8: Soft Bump - 60%",
        "#9: Soft Bump - 30%",
        "#10: Double Click - 100%",
        "#11: Double Click - 60%",
        "#12: Triple Click - 100%",
        "#13: Soft Fuzz - 60%",
        "#14: Strong Buzz - 100%",
        "#15: 750ms Alert 100%",
        "#16: 1000ms Alert 100%",
        "#17: Strong Click 1 - 100%",
        "#18: Strong Click 2 - 80%",
        "#19: Strong Click 3 - 60%",
        "#20: Strong Click 4 - 30%"



};


*/

/*
  Code generated by ChatGPT on [2022-01-17].
  Generated in response to the prompt: "make defines from the following list similar to the provided example:
0: 1x will be #define FB_BRAKE_FACTOR_1x 0
and then create structs and populate them with the defines provided and also provide similar list for the loop_gain "
*/
// Warning the following values are  only valid for DRV2605L
// Defines for Rated Voltage @tSample = 300us
// DRV 2604 and 2605
#define DRV_RV_LRA_CL_300US_2_0V_RMS 0x53
#define DRV_RV_LRA_CL_300US_2_1V_RMS 0x57
#define DRV_RV_LRA_CL_300US_2_2V_RMS 0x5B
#define DRV_RV_LRA_CL_300US_2_3V_RMS 0x5F
#define DRV_RV_LRA_CL_300US_2_4V_RMS 0x63
// DRV 2605L
#define DRV_L_RV_LRA_CL_300US_2_0V_RMS 0x53
#define DRV_L_RV_LRA_CL_300US_2_2V_RMS 0x5B
#define DRV_L_RV_LRA_CL_300US_2_4V_RMS 0x64

// Defines for Overdrive Clamp Voltage
#define DRV_LRA_OD_CLAMP_2_05V 0x5D
#define DRV_LRA_OD_CLAMP_2_82V 0x80
#define DRV_LRA_OD_CLAMP_3_02V 0x8A

// DRV 2605L
#define DRV_L_LRA_OD_CLAMP_2_05V 0x60
#define DRV_L_LRA_OD_CLAMP_2_82V 0x84
#define DRV_L_LRA_OD_CLAMP_3_02V 0x8E
// Defines for Feedback Control
#define DRV_ERM 0
#define DRV_LRA 1

#define DRV_FB_BRAKE_FACTOR_1X 0
#define DRV_FB_BRAKE_FACTOR_2X 1
#define DRV_FB_BRAKE_FACTOR_3X 2
#define DRV_FB_BRAKE_FACTOR_4X 3
#define DRV_FB_BRAKE_FACTOR_6X 4
#define DRV_FB_BRAKE_FACTOR_8X 5
#define DRV_FB_BRAKE_FACTOR_16X 6
#define DRV_FB_BRAKE_DISABLED 7
#define DRV_LOOP_GAIN_LOW 0
#define DRV_LOOP_GAIN_MEDIUM 1
#define DRV_LOOP_GAIN_HIGH 2
#define DRV_LOOP_GAIN_VERY_HIGH 3
#define DRV_BEMF_GAIN_0_255X_3_75X 0
#define DRV_BEMF_GAIN_0_7875X_7_5X 1
#define DRV_BEMF_GAIN_1_365X_15X 2  // default
#define DRV_BEMF_GAIN_3X_22_5X 3

// Defines for Control 1
#define DRV_STARTUP_BOOST_ON 1
#define DRV_STARTUP_BOOST_OFF 0

#define DRV_AC_COUPLE_DC 0
#define DRV_AC_COUPLE_AC 1

#define DRV_DRIVE_TIME_19 19
#define DRV_DRIVE_TIME_24 24
#define DRV_DRIVE_TIME_34 34

// Defines for Control 2
#define DRV_BIDIR_INPUT_BI 1  // default
#define DRV_BIDIR_INPUT_UNI 0

#define DRV_BRAKE_STABILIZER_ON 1  // default
#define DRV_BRAKE_STABILIZER_OFF 0
#define DRV_SAMPLE_TIME_300US 3  // default
#define DRV_SAMPLE_TIME_250US 2
#define DRV_SAMPLE_TIME_200US 1
#define DRV_SAMPLE_TIME_150US 0
#define DRV_BLANKING_TIME_25_75US 1  // default
#define DRV_BLANKING_TIME_15_45US 0
#define DRV_IDISS_TIME_25_75US 1  // default
#define DRV_IDISS_TIME_15_45US 0

// Defines for Control 3
#define DRV_NG_THRESH_DIS 0
#define DRV_NG_THRESH_2PER 1
#define DRV_NG_THRESH_4PER 2
#define DRV_NG_THRESH_8PER 3
#define DRV_ERM_CLOSED_LOOP 0
#define DRV_ERM_OPEN_LOOP 1       // default
#define DRV_SUPPLY_COMP_DIS_ON 0  // default
#define DRV_SUPPLY_COMP_DIS_OFF 1
#define DRV_DATA_FORMAT_RTP_SIGNED 0  // default
#define DRV_DATA_FORMAT_RTP_UNSIGNED 1
#define DRV_LRA_DRIVE_MODE_ONCE 0  // default
#define DRV_LRA_DRIVE_MODE_TWICE 1
#define DRV_NPWM_ANALOG_PWM 0  // default
#define DRV_NPWM_ANALOG_ANALOG 1
#define DRV_LRA_AUTO_RES_MODE 0  // default
#define DRV_LRA_OPEN_LOOP 1      // default

// Defines for Control 4
#define DRV_ZC_DET_TIME_100US 0  // default
#define DRV_ZC_DET_TIME_200US 1
#define DRV_ZC_DET_TIME_300US 2
#define DRV_ZC_DET_TIME_490US 3
#define DRV_AUTOCAL_TIME_125MS 0
#define DRV_AUTOCAL_TIME_250MS 1
#define DRV_AUTOCAL_TIME_500MS 2  // default
#define DRV_AUTOCAL_TIME_1000MS 3
#define DRV_OTP_PRG_OFF 0  // default
#define DRV_OTP_PRG_ON 1

// Defines for Control 5
#define DRV_AUTO_OL_CNT_3_ATTEMPTS 0
#define DRV_AUTO_OL_CNT_4_ATTEMPTS 1
#define DRV_AUTO_OL_CNT_5_ATTEMPTS 2  // default
#define DRV_AUTO_OL_CNT_6_ATTEMPTS 3
#define DRV_LRA_AUTO_OPEN_LOOP_NEVER 0  // default
#define DRV_LRA_AUTO_OPEN_LOOP_AUTO 1
#define DRV_PLAYBACK_INTERVAL_5ms 0  // default
#define DRV_PLAYBACK_INTERVAL_1ms 1
#define DRV_BLANKING_TIME_MSB_DEFAULT 0  // Add more defines here as needed based on Control2
#define DRV_IDISS_TIME_MSB_DEFAULT 0     // Add more defines here as needed based on Control2

// Defines for Mode
#define DRV_DEV_RESET_OFF 0
#define DRV_DEV_RESET_ON 1
#define DRV_STANDBY_READY 0
#define DRV_STANDBY_STANDBY 1  // default

#define DRV2605_REG_CONTROL5 0x1F
#define DRV2605_LRA_OPEN_LOOP_PERIOD_REGISTER 0x20  // LRA open-loop period (μs) = OL_LRA_PERIOD[6:0] × 98.46 μs

#define DRV_OL_LRA_PERIOD_175 0x3A  // ~175Hz = T = 5700 μs => 5700 μs / 98.46 μs = 58.0366 || ~185Hz = 54

static const char *TAG_DRV = "DRV2605L";
/**************************************************************************/
/*!
  @brief The DRV2605 driver utility class, extending the Ardafruit library
        the DRV2605_UTIL class controls all drivers
*/
/**************************************************************************/
class DRV2605_UTIL : public Adafruit_DRV2605 {
   public:
    union Rated_Voltage_Register {
        struct
        {
            uint8_t RATED_VOLTAGE;
        } bits;
        uint8_t reg;
    };
    union OD_Clamp_Register {
        struct
        {
            uint8_t OD_CLAMP;
        } bits;
        uint8_t reg;
    };
    union Feedback_Control_Register {
        struct
        {
            uint8_t BEMF_GAIN : 2;
            uint8_t LOOP_GAIN : 2;
            uint8_t FB_BRAKE_FACTOR : 3;
            uint8_t N_ERM_LRA : 1;
        } bits;
        uint8_t reg;
    };

    union Control1_Register {
        struct
        {
            uint8_t DRIVE_TIME : 5;
            uint8_t AC_COUPLE : 1;
            uint8_t : 1;
            uint8_t STARTUP_BOOST : 1;
        } bits;
        uint8_t reg;
    };

    union Control2_Register {
        struct
        {
            uint8_t IDISS_TIME : 2;
            uint8_t BLANKING_TIME : 2;
            uint8_t SAMPLE_TIME : 2;
            uint8_t BRAKE_STABILIZE : 1;
            uint8_t BIDIR_INPUT : 1;
        } bits;
        uint8_t reg;
    };

    union Control3_Register {
        struct
        {
            uint8_t LRA_OPEN_LOOP : 1;
            uint8_t N_PWM_ANALOG : 1;
            uint8_t LRA_DRIVE_MODE : 1;
            uint8_t DATA_FORMAT_RTP : 1;
            uint8_t SUPPLY_COMP_DIS : 1;
            uint8_t ERM_OPEN_LOOP : 1;
            uint8_t NG_THRESH : 2;
        } bits;
        uint8_t reg;
    };

    union Control4_Register {
        struct
        {
            uint8_t OTP_PROGRAM : 1;
            uint8_t : 1;
            uint8_t OTP_STATUS : 1;
            uint8_t : 1;
            uint8_t AUTO_CAL_TIME : 2;
            uint8_t ZC_DET_TIME : 2;
        } bits;
        uint8_t reg;
    };

    union Control5_Register {
        struct
        {
            uint8_t IDISS_TIME : 2;
            uint8_t BLANKING_TIME : 2;
            uint8_t PLAYBACK_INTERVAL : 1;
            uint8_t LRA_AUTO_OPEN_LOOP : 1;
            uint8_t AUTO_OL_CNT : 2;
        } bits;
        uint8_t reg;
    };

    union LRA_Open_Loop_Period_Register {
        struct
        {
            uint8_t OL_LRA_PERIOD : 7;
            uint8_t : 1;
        } bits;
        uint8_t reg;
    };

    /// @brief Memory playback intervall
    typedef enum {
        ts_5ms,  // default
        ts_1ms
    } drv_playbackInterval_t;

    /// Returns the singleton instance of the DRV2605_UTIL class.
    static DRV2605_UTIL &getInstance();

    /// Sets the rated voltage for the driver.
    /// @param ratedVoltage The value to set the rated voltage to.
    void set_ratedVoltage(uint8_t ratedVoltage);

    /// Sets the overdrive clamp for the driver.
    /// @param odClamp The value to set the overdrive clamp to.
    void set_odClamp(uint8_t odClamp);

    /// Runs the auto calibration process for the motor driver.
    void autoCalibrate();

    /// Initializes the motor driver, setting up registers and channels.
    void init();

    /// Sets the trigger pins for the drivers.
    /// Note: The Ariadne circuit has no triggers wired to the driver
    /// @param PortA The trigger pin for port A.
    /// @param PortB The trigger pin for port B.
    void setTrigger(uint8_t PortA, uint8_t PortB);

    /// Triggers the driver of device A.
    /// Note: The Ariadne circuit has no triggers wired to the driver
    void triggerA();

    /// Stops the driver of device A.
    /// Note: The Ariadne circuit has no triggers wired to the driver
    void stopTriggerA();

    /// Triggers the driver of device B.
    /// Note: The Ariadne circuit has no triggers wired to the driver
    void triggerB();

    /// Stops the driver of device B.
    void stopTriggerB();

    /// Starts both driverss.
    /// Note: The Ariadne circuit has no triggers wired to the driver
    void triggerStart();

    /// Stops both drivers.
    /// Note: The Ariadne circuit has no triggers wired to the driver
    void triggerStop();

    /// Sets the enable pins for the drivers.
    /// @param pinA Set the enable pin for device A.
    /// @param pinB Set the enable pin for device B.
    void setEnablePins(uint8_t pinA, uint8_t pinB);

    /// Enables both channels of the driver.
    void enableAll();

    /// Disables both channels of the driver.
    void disableAll();
    /// Enables or disables the DRV2605 driver of the respective port.
    /// @param PortA Whether to enable port A.
    /// @param PortB Whether to enable port B.
    void enable(bool PortA, bool PortB);

    /// Enables the driver of port A.
    void enableA();

    /// Disables the driver of port A.
    void disableA();

    /// Enables the driver of port B.
    void enableB();

    /// Disables the driver of port B.
    void disableB();

    /// Returns the playback interval setting of the driver.
    /// @return Playback Interval.
    drv_playbackInterval_t playbackInterval();

    /// Selects the memory playback interval of the driver.
    /// @param interval playback interval; can be 5ms or 1ms.
    void setPlaybackInterval(drv_playbackInterval_t interval);

    /// Triggers a stimulation on port A or port B.
    /// Duration and amplitude are controlled using the respective getter and
    /// setter functions the Ariadne class provides.
    void stimulate();

   private:
    DRV2605_UTIL(void);
    DRV2605_UTIL &operator=(const DRV2605_UTIL &) = delete;

    esp_timer_handle_t stimulation_timer;
    static void stimulation_timer_callback(void *arg);

    uint8_t m_trig_A = D1;
    uint8_t m_trig_B = D0;

    uint8_t m_en_A = D2;
    uint8_t m_en_B = D3;

    /// is enabled {portA, portB}
    bool m_enable_state[2] = {false, false};

    bool m_use_open_loop = true;

    union Rated_Voltage_Register m_ratedVoltage;
    union OD_Clamp_Register m_OD_Clamp;
    union Feedback_Control_Register m_feedback_control;
    union Control1_Register m_control1;
    union Control2_Register m_control2;
    union Control3_Register m_control3;
    union Control4_Register m_control4;
    union Control5_Register m_control5;
    union LRA_Open_Loop_Period_Register m_LRA_open_loop_period;
};

#endif  // DRV2605_UTIL_H